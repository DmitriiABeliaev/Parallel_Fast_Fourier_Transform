#include "core/cxxopts.h"
#include "core/get_time.h"
#include <iostream>
#include <vector>
#include <complex>
#include <cmath>
#include <algorithm>
#include <stdexcept>

#define DEFAULT_NUMBER_OF_SAMPLES "1024"
#define DEFAULT_AMPLITUDE "1.0"
#define DEFAULT_FREQUENCY "50.0"
#define DEFAULT_SAMPLING_RATE "1000.0"
#define DEFAULT_ALGORITHM_TYPE "Recursive"
#define PI M_PI
#define BASE 2.0
#define EXPONENTIAL_PART (std::pow(BASE, 2 * PI))
#define IMAGINARY_UNIT std::complex<double>(0, 1)
#define OMEGA(n_samples) ((EXPONENTIAL_PART * IMAGINARY_UNIT) / static_cast<double>(n_samples))

/** 
 * (This comment has been generated by GenAI based on the implementation of the function)
 * @brief Generates a sine wave sampled at regular intervals.
 * 
 * This function creates a sine wave based on the specified number of samples, amplitude,
 * frequency, and sampling rate. The resulting sine wave is represented as a vector of
 * complex numbers, where the real part contains the sine wave values, and the imaginary 
 * part is set to 0.0 (useful for FFT processing).
 * 
 * @param n_samples The total number of samples to generate.
 * @param amplitude The amplitude of the sine wave (peak value).
 * @param frequency The frequency of the sine wave in Hz (cycles per second).
 * @param sampling_rate The rate at which the sine wave is sampled in Hz (samples per second).
 * @return std::vector<std::complex<double>> A vector containing the sampled sine wave values 
 *         as complex numbers with 0.0 as the imaginary part.
 */
std::vector<std::complex<double>> generateSineWave(uint n_samples, double amplitude, double frequency, double sampling_rate) {
    // Vector to store the samples from the sine wave
    std::vector<std::complex<double>> sine_wave(n_samples);

    for (uint n = 0; n < n_samples; ++n) {
        double time_step = n / sampling_rate;
        // Compute the value of the sine wave at the current time step
        double value = amplitude * std::sin(2 * M_PI * frequency * time_step);
        sine_wave[n] = {value, 0.0};
    }

    return sine_wave;
}


/**
 * Implementation based on the Cooley-Tukey algorithm for one-dimensional, unordered, radix-2 FFT.
 * This function computes the FFT iteratively.
 * It uses a two-array method where intermediate results are stored in an auxiliary array at each stage. 
 * 
 * @param input_signal: A vector of complex numbers representing the time-domain input signal.
 * @param output_signal: A vector of complex numbers to store the frequency-domain output signal.
 * @param n_samples: The number of input samples.
 * 
 * https://www.w3computing.com/articles/how-to-implement-a-fast-fourier-transform-fft-in-cpp/
 * 
 */
void iterativeFFT(const std::vector<std::complex<double>>& input_signal, 
std::vector<std::complex<double>>& output_signal, int n_samples) {
    using Complex = std::complex<double>;

    // Ensure output_signal is correctly sized
    output_signal = input_signal;
    size_t N = static_cast<size_t>(n_samples);

    // Bit-reversed addressing permutation
    size_t j = 0;
    for (size_t i = 1; i < N; ++i) {
        size_t bit = N >> 1;
        while (j & bit) {
            j ^= bit;
            bit >>= 1;
        }
        j ^= bit;

        if (i < j) {
            std::swap(output_signal[i], output_signal[j]);
        }
    }

    // Iterative FFT
    for (size_t len = 2; len <= N; len <<= 1) {
        double angle = -2.0 * PI / len;
        Complex wlen(cos(angle), sin(angle));
        for (size_t i = 0; i < N; i += len) {
            Complex w(1.0);
            for (size_t j = 0; j < len / 2; ++j) {
                size_t index1 = i + j;
                size_t index2 = i + j + len / 2;

                // Butterfly operation
                Complex u = output_signal[index1];
                Complex v = output_signal[index2] * w;
                output_signal[index1] = u + v;
                output_signal[index2] = u - v;

                // Update twiddle factor
                w *= wlen;
            }
        }
    }
}

/**
 * Implementation based on the Cooley-Tukey algorithm for one-dimensional, unordered, radix-2 FFT.
 * This function computes the FFT recursively.
 * It uses a two-array method where intermediate results are stored in an auxiliary array at each stage. 
 * 
 * @param input_signal: A vector of complex numbers representing the time-domain input signal.
 * @param output_signal: A vector of complex numbers to store the frequency-domain output signal.
 * @param n_samples: The number of input samples.
 * @param omega:The angular frequency of the signal, represented as a complex number.
 */
void recursiveFFT(const std::vector<std::complex<double>>& input_signal, 
std::vector<std::complex<double>>& output_signal, uint n_samples, std::complex<double> omega) {
        // Base case: if the number of samples is 1, simply copy the input to the output
    if (n_samples == 1) {
        output_signal[0] = input_signal[0];
        return;
    }

    // Divide the input_signal into even-indexed and odd-indexed elements
    std::vector<std::complex<double>> even_signal(n_samples / 2);
    std::vector<std::complex<double>> odd_signal(n_samples / 2);
    for (int i = 0; i < n_samples / 2; ++i) {
        even_signal[i] = input_signal[2 * i];
        odd_signal[i] = input_signal[2 * i + 1];
    }

    // Prepare vectors to store intermediate results
    std::vector<std::complex<double>> even_indexed_output(n_samples / 2);
    std::vector<std::complex<double>> odd_indexed_output(n_samples / 2);

    // Compute omega squared
    std::complex<double> omega_squared = std::polar(1.0, -2.0 * M_PI / (n_samples / 2));

    // Recursive calls for even and odd parts
    recursiveFFT(even_signal, even_indexed_output, n_samples / 2, omega_squared);
    recursiveFFT(odd_signal, odd_indexed_output, n_samples / 2, omega_squared);

    std::complex<double> omega_power = 1.0;  // Initialize ω^0
    std::complex<double> omega_increment = std::polar(1.0, -2.0 * M_PI / n_samples);  // Precompute ω
    for (int i = 0; i < n_samples / 2; ++i) {
        std::complex<double> temp = omega_power * odd_indexed_output[i];
        output_signal[i] = even_indexed_output[i] + temp;
        output_signal[i + n_samples / 2] = even_indexed_output[i] - temp;
        omega_power *= omega_increment; 
    }
}

// https://www.educative.io/answers/how-to-check-if-a-number-is-a-power-of-2-in-cpp
void validateNumSamplesToBePowerOfTwo(uint n_samples) {
    uint i = n_samples & (n_samples - 1);

    if (i != 0) {
        throw std::invalid_argument("The number of samples provided must be power of two.");
    }
}

void validateAlgorithmType(std::string algorithm_type) {
    if (algorithm_type != "recursive" && algorithm_type != "iterative") {
        throw std::invalid_argument("The algorithm provided could only be recursive or iterative.");
    }
}

void printFirstOutputs(std::vector<std::complex<double>>& output_signal, uint n_samples) {

    if (n_samples <= 8) {
        // If there are only a few samples print all of the results
        std::cout << std::endl;
        std::cout << "First " << n_samples << " samples:" << std::endl;
        int item_counter = 1;
        for (const auto& item : output_signal) {
            std::cout << item_counter << ". " << item << std::endl;
            item_counter++;
        }
    } else {
        // If there are more samples only print the first 10
        std::cout << std::endl;
        std::cout << "First 10 samples:" << std::endl;
        for (int i = 1; i < 11; i++) {
            std::cout << i << ". " << output_signal[i] << std::endl;
        }
    }     
}

int main(int argc, char *argv[]) {
    cxxopts::Options options(
        "Fast_Fourier_Transfrom",
        "Calculate the Fourier Transform of a sine wave using serial execution.");
    options.add_options(
        "",
        {
            {"n_samples", "Number of Samples", 
            cxxopts::value<uint>()->default_value(DEFAULT_NUMBER_OF_SAMPLES)},
            {"amplitude", "Amplitude of the Sine Wave",
            cxxopts::value<double>()->default_value(DEFAULT_AMPLITUDE)},
            {"frequency", "Frequency of the Sine Wave",
            cxxopts::value<double>()->default_value(DEFAULT_FREQUENCY)},
            {"sampling_rate", "Sampling Rate",
            cxxopts::value<double>()->default_value(DEFAULT_SAMPLING_RATE)},
            {"algorithm_type", "Type of the serial algorithm (Iterative or Recursive)",
            cxxopts::value<std::string>()->default_value(DEFAULT_ALGORITHM_TYPE)}
        });

        auto cl_options = options.parse(argc, argv);
        uint n_samples = cl_options["n_samples"].as<uint>();
        double amplitude = cl_options["amplitude"].as<double>();
        double frequency = cl_options["frequency"].as<double>();
        double sampling_rate = cl_options["sampling_rate"].as<double>();
        std::string algorithm_type = cl_options["algorithm_type"].as<std::string>();

        // Validate the number of samples to be power of two to satisfy the Cooley-Tukey algorithm assumption
        try {
            validateNumSamplesToBePowerOfTwo(n_samples);
        } catch (const std::invalid_argument& error) {
            std::cerr << "Caught an invalid argument exception: " << error.what() << std::endl;
            std::exit(EXIT_FAILURE);
        }

        // Validate the type of algorithm provided by the user
        try {
            // Convert the type into lower case
            std::transform(algorithm_type.begin(), algorithm_type.end(), algorithm_type.begin(), ::tolower);
            validateAlgorithmType(algorithm_type);
        } catch (const std::invalid_argument& error) {
            std::cerr << "Caught an invalid argument exception: " << error.what() << std::endl;
            std::exit(EXIT_FAILURE);
        }

        // Print the command line inputs
        std::cout << "Number of Samples: " << n_samples << std::endl;
        std::cout << "Amplitude: " << amplitude << std::endl;
        std::cout << "Frequency: " << frequency << " Hz" << std::endl;
        std::cout << "Sampling Rate: " << sampling_rate << " Hz" << std::endl;
        std::cout << "Algorithm Type: " << algorithm_type << std::endl;

        // Generate a sine wave to be used for Fast Fourier Transform
        auto sine_wave = generateSineWave(n_samples, amplitude, frequency, sampling_rate);

        // Perform Fast Fourier Transform serially
        if (algorithm_type == "iterative") {
            std::cout << std::endl;
            std::cout << "Executing the iterative serial algorithm..." << std::endl;
            std::cout << std::endl;

            // Timer instantiation
            timer iterative_alg_timer;
            double time_taken = 0.0;

            // -------------------------------------------------------------------
            iterative_alg_timer.start();

            // Iterative approach
            std::vector<std::complex<double>> output_data(n_samples);
            iterativeFFT(sine_wave, output_data, n_samples);
            
            time_taken = iterative_alg_timer.stop();
            // -------------------------------------------------------------------

            // Print the time taken to execute the algorithm
            std::cout << "The time taken to execute the iterative FFT (serial version): " << time_taken << std::endl;

            // Print first few outputs for verification
            printFirstOutputs(output_data, n_samples);

        } else {
            std::cout << std::endl;
            std::cout << "Executing the recursive serial algorithm..." << std::endl;
            std::cout << std::endl;

            // Obtain omega based on number of samples
            auto omega = OMEGA(n_samples);

            // Timer instantiation
            timer recursive_alg_timer;
            double time_taken = 0.0;

            // -------------------------------------------------------------------
            recursive_alg_timer.start();

            // Recursive approach
            std::vector<std::complex<double>> output_data(n_samples);
            recursiveFFT(sine_wave, output_data, n_samples, omega);

            time_taken = recursive_alg_timer.stop();
            // -------------------------------------------------------------------

            std::cout << "The time taken to execute the recursive FFT (serial version): " << time_taken << std::endl;

            printFirstOutputs(output_data, n_samples);
        }
}