#include "common/cxxopts.h"
#include <iostream>
#include <vector>
#include <complex>
#include <cmath>
#include <algorithm>
#include <stdexcept>

#define DEFAULT_NUMBER_OF_SAMPLES "1024"
#define DEFAULT_AMPLITUDE "1.0"
#define DEFAULT_FREQUENCY "50.0"
#define DEFAULT_SAMPLING_RATE "1000.0"
#define DEFAULT_ALGORITHM_TYPE "Recursive"

/** 
 * (This comment has been generated by GenAI based on the implementation of the function).a 
 * @brief Generates a sine wave sampled at regular intervals.
 * 
 * This function creates a sine wave based on the specified number of samples, amplitude,
 * frequency, and sampling rate. The resulting sine wave is represented as a vector of
 * complex numbers, where the real part contains the sine wave values, and the imaginary 
 * part is set to 0.0 (useful for FFT processing).
 * 
 * @param n_samples The total number of samples to generate.
 * @param amplitude The amplitude of the sine wave (peak value).
 * @param frequency The frequency of the sine wave in Hz (cycles per second).
 * @param sampling_rate The rate at which the sine wave is sampled in Hz (samples per second).
 * @return std::vector<std::complex<double>> A vector containing the sampled sine wave values 
 *         as complex numbers with 0.0 as the imaginary part.
 */
std::vector<std::complex<double>> generateSineWave(uint n_samples, double amplitude, double frequency, double sampling_rate) {
    // Vector to store the samples from the sine wave
    std::vector<std::complex<double>> sine_wave(n_samples);

    for (uint n = 0; n < n_samples; ++n) {
        double time_step = n / sampling_rate;
        // Compute the value of the sine wave at the current time step
        double value = amplitude * std::sin(2 * M_PI * frequency * time_step);
        sine_wave[n] = {value, 0.0};
    }

    return sine_wave;
}

/**
 * Implementation based on the Cooley-Tukey algorithm for one-dimensional, unordered, radix-2 FFT.
 * This function computes the FFT iteratively, strictly following the pseudocode provided.
 * It uses a two-array method where intermediate results are stored in an auxiliary array at each stage. 
 * 
 * @param X: A vector of complex numbers representing the time-domain input signal.
 * @param Y: A vector of complex numbers to store the frequency-domain output signal (same size as `X`).
 * @param n: The number of input samples (must be a power of 2).
 * @throws std::invalid_argument if the input size `n` is not a power of 2 or is not positive.
 */
void iterativeFFT(const std::vector<std::complex<double>>& X, std::vector<std::complex<double>>& Y, int n) {
    // Step 3: Compute r = log2(n)
    int r = static_cast<int>(std::log2(n));
    
    // Step 4: Initialize R with the input array X
    std::vector<std::complex<double>> R(n);
    for (int i = 0; i < n; ++i) {
        R[i] = X[i];
    }
    
    // Outer loop: Iterate over each stage
    for (int m = 0; m < r; ++m) {
        // Step 7: Copy R into S
        std::vector<std::complex<double>> S(n);
        for (int i = 0; i < n; ++i) {
            S[i] = R[i];
        }

        // Step 8: Inner loop
        for (int i = 0; i < n; ++i) {
            // Step 9: Compute j and k based on the binary representation of i
            int mask = (1 << (r - m - 1)); // Mask to extract the m-th bit
            int j = i & ~mask;            // Set the m-th bit to 0
            int k = i | mask;             // Set the m-th bit to 1

            // Step 12: Perform the Cooley-Tukey butterfly operation
            std::complex<double> twiddle = std::polar(1.0, -2.0 * M_PI * (k % (1 << (m + 1))) / (1 << (m + 1)));
            R[i] = S[j] + twiddle * S[k];
        }
    }

    // Step 15: Copy the result from R to Y
    for (int i = 0; i < n; ++i) {
        Y[i] = R[i];
    }
}

void validateNumSamplesToBeEven(uint n_samples) {
    if (n_samples % 2 == 1) {
        throw std::invalid_argument("The number of samples provided must be an even number.");
    }
}

void validateAlgorithmType(std::string algorithm_type) {
    if (algorithm_type != "recursive" && algorithm_type != "iterative") {
        throw std::invalid_argument("The algorithm provided could only be recursive or iterative.");
    }
}

int main(int argc, char *argv[]) {
    cxxopts::Options options(
        "Fast_Fourier_Transfrom",
        "Calculate the Fourier Transform of a sine wave using serial execution.");
    options.add_options(
        "",
        {
            {"n_samples", "Number of Samples", 
            cxxopts::value<uint>()->default_value(DEFAULT_NUMBER_OF_SAMPLES)},
            {"amplitude", "Amplitude of the Sine Wave",
            cxxopts::value<double>()->default_value(DEFAULT_AMPLITUDE)},
            {"frequency", "Frequency of the Sine Wave",
            cxxopts::value<double>()->default_value(DEFAULT_FREQUENCY)},
            {"sampling_rate", "Sampling Rate",
            cxxopts::value<double>()->default_value(DEFAULT_SAMPLING_RATE)},
            {"algorithm_type", "Type of the serial algorithm (Iterative or Recursive)",
            cxxopts::value<std::string>()->default_value(DEFAULT_ALGORITHM_TYPE)}
        });

        auto cl_options = options.parse(argc, argv);
        uint n_samples = cl_options["n_samples"].as<uint>();
        double amplitude = cl_options["amplitude"].as<double>();
        double frequency = cl_options["frequency"].as<double>();
        double sampling_rate = cl_options["sampling_rate"].as<double>();
        std::string algorithm_type = cl_options["algorithm_type"].as<std::string>();

        // Validate the number of samples to be even to satisfy the Cooley-Tukey algorithm assumption
        try {
            validateNumSamplesToBeEven(n_samples);
        } catch (const std::invalid_argument& error) {
            std::cerr << "Caught an invalid argument exception: " << error.what() << std::endl;
            std::exit(EXIT_FAILURE);
        }

        // Validate the type of algorithm provided by the user
        try {
            // Convert the type into lower case
            std::transform(algorithm_type.begin(), algorithm_type.end(), algorithm_type.begin(), ::tolower);
            validateAlgorithmType(algorithm_type);
        } catch (const std::invalid_argument& error) {
            std::cerr << "Caught an invalid argument exception: " << error.what() << std::endl;
            std::exit(EXIT_FAILURE);
        }

        // Print the command line inputs
        std::cout << "Number of Samples: " << n_samples << std::endl;
        std::cout << "Amplitude: " << amplitude << std::endl;
        std::cout << "Frequency: " << frequency << " Hz" << std::endl;
        std::cout << "Sampling Rate: " << sampling_rate << " Hz" << std::endl;
        std::cout << "Algorithm Type: " << algorithm_type << std::endl;

        // Generate a sine wave to be used for Fast Fourier Transform
        auto sine_wave = generateSineWave(n_samples, amplitude, frequency, sampling_rate);

        // Perform Fast Fourier Transform serially
        std::vector<std::complex<double>> output_data(n_samples);
        iterativeFFT(sine_wave, output_data, n_samples);
}