#include "core/cxxopts.h"
#include "core/get_time.h"
#include "core/utils.h"
#include <iostream>
#include <vector>
#include <complex>
#include <cmath>
#include <algorithm>
#include <stdexcept>
#include <thread>
#include <mutex>

#define DEFAULT_NUMBER_OF_SAMPLES "1024"
#define DEFAULT_AMPLITUDE "1.0"
#define DEFAULT_FREQUENCY "50.0"
#define DEFAULT_SAMPLING_RATE "1000.0"
#define DEFAULT_NUM_OF_THREADS "4"
#define PI M_PI
#define BASE 2.0
#define EXPONENTIAL_PART (std::pow(BASE, 2 * PI))
#define IMAGINARY_UNIT std::complex<double>(0, 1)
#define OMEGA(n_samples) ((EXPONENTIAL_PART * IMAGINARY_UNIT) / static_cast<double>(n_samples))

/** 
 * (This comment has been generated by GenAI based on the implementation of the function)
 * @brief Generates a sine wave sampled at regular intervals.
 * 
 * This function creates a sine wave based on the specified number of samples, amplitude,
 * frequency, and sampling rate. The resulting sine wave is represented as a vector of
 * complex numbers, where the real part contains the sine wave values, and the imaginary 
 * part is set to 0.0 (useful for FFT processing).
 * 
 * @param n_samples The total number of samples to generate.
 * @param amplitude The amplitude of the sine wave (peak value).
 * @param frequency The frequency of the sine wave in Hz (cycles per second).
 * @param sampling_rate The rate at which the sine wave is sampled in Hz (samples per second).
 * @return std::vector<std::complex<double>> A vector containing the sampled sine wave values 
 *         as complex numbers with 0.0 as the imaginary part.
 */
std::vector<std::complex<double>> generateSineWave(uint n_samples, double amplitude, double frequency, double sampling_rate) {
    // Vector to store the samples from the sine wave
    std::vector<std::complex<double>> sine_wave(n_samples);

    for (uint n = 0; n < n_samples; ++n) {
        double time_step = n / sampling_rate;
        // Compute the value of the sine wave at the current time step
        double value = amplitude * std::sin(2 * M_PI * frequency * time_step);
        sine_wave[n] = {value, 0.0};
    }

    return sine_wave;
}

// Comparator function to sort by the first element (ID) in the tuple (Written by GenAI)
bool compareByID(const std::tuple<uint, double> &a, const std::tuple<uint, double> &b) {
    return std::get<0>(a) < std::get<0>(b);
}

void parallelFFTExecution(
    const std::vector<std::complex<double>>& input_signal,
    std::vector<std::complex<double>>& output_signal,
    uint n_samples,
    uint start_index,
    uint end_index,
    uint id,
    std::vector<std::tuple<uint, double>>& times_taken,
    CustomBarrier& barrier,
    std::mutex& times_taken_mutex)
{
    timer thread_timer;
    double thread_time_taken = 0.0;
    using Complex = std::complex<double>;
    size_t log2n = static_cast<size_t>(std::log2(n_samples));
    const size_t N = static_cast<size_t>(n_samples);

    // -------------------------------------------------------------------
    thread_timer.start();

    // Let thread 0 handle the bit reversal
    if (id == 0) {
        size_t j = 0;
        for (size_t i = 1; i < N; ++i) {
            size_t bit = N >> 1;
            while (j & bit) {
                j ^= bit;
                bit >>= 1;
            }
            j ^= bit;

            if (i < j) {
                std::swap(output_signal[i], output_signal[j]);
            }
        }
    }

    // Synchronize all threads after bit reversal
    barrier.wait();

    // Iterative FFT: Process data in stages
    for (size_t s = 1; s <= log2n; ++s) {
        size_t len = 1 << s; // Current stage size
        double angle = -2.0 * PI / len;
        Complex wlen(cos(angle), sin(angle));

        // Align thread ranges to current FFT block size
        size_t effective_start = std::max(static_cast<size_t>((start_index / len) * len), static_cast<size_t>(start_index));
        if (start_index % len != 0) effective_start += len; // Align to next multiple of len

        size_t effective_end = std::min(static_cast<size_t>(((end_index + len - 1) / len) * len), static_cast<size_t>(end_index));

        if (effective_start >= effective_end) {
            std::cout << "Thread " << id << ": Skipping stage " << s << " due to invalid range" << std::endl;
            barrier.wait();
            continue;
        }

        // Process data in groups of size 'len'
        for (size_t i = effective_start; i < effective_end; i += len) {
            Complex w(1.0); // Initialize twiddle factor
            for (size_t j = 0; j < len / 2; ++j) {
                size_t index1 = i + j;
                size_t index2 = i + j + len / 2;

                if (index1 >= N || index2 >= N) {
                    std::cerr << "Invalid indices detected: index1 = " << index1 << ", index2 = " << index2 << " in thread " << id << "\n";
                    continue; // Skip invalid computations
                }

                // Butterfly computations
                Complex u = output_signal[index1];
                Complex v = output_signal[index2] * w;

                output_signal[index1] = u + v;
                output_signal[index2] = u - v;

                w *= wlen; // Update twiddle factor
            }
        }

        // Synchronize all threads after each stage
        barrier.wait();
    }

    thread_time_taken = thread_timer.stop();
    // -------------------------------------------------------------------

    // Append the time taken for this thread
    times_taken[id] = std::make_tuple(id, thread_time_taken);
}

void parallelFFT(const std::vector<std::complex<double>>& input_signal, 
std::vector<std::complex<double>>& output_signal, uint n_samples, uint n_threads) {

    timer parallel_timer;
    double total_time_taken = 0.0;
    std::vector<std::tuple<uint, double>> times_taken; // Stores (Thread ID, Time Taken Per Thread)
    times_taken.resize(n_threads);
    CustomBarrier barrier(n_threads);
    std::mutex times_taken_mutex;

    // Copy data from input_signal to output_signal
    output_signal = input_signal;

    // Create threads and distribute the work across
    // No need for remainders as the number of samples are checked to be an even number.
    std::vector<std::thread> threads;
    threads.resize(n_threads);
    uint num_elements_per_thread = n_samples / n_threads;

    // Launch the threads
    // -------------------------------------------------------------------
    parallel_timer.start();
    for (uint i = 0; i < n_threads; i++) {
        // Determine the range of the input signal each thread will work on
        uint start_index = num_elements_per_thread * i;
        uint end_index = num_elements_per_thread * (i + 1);

        // Each thread handles both copying and FFT execution
        threads[i] = std::thread(parallelFFTExecution, std::ref(input_signal), std::ref(output_signal), n_samples, 
        start_index, end_index, i, std::ref(times_taken), std::ref(barrier), std::ref(times_taken_mutex));
    }

    // Join all the threads
    for (uint i = 0; i < n_threads; i++) {
        threads[i].join();
    }

    total_time_taken = parallel_timer.stop();
    // -------------------------------------------------------------------

    // Print the time taken for each thread
    std::sort(times_taken.begin(), times_taken.end(), compareByID);
    std::cout << std::endl;
    std::cout << "thread_id, time_taken" << std::endl;

    for (uint i = 0; i < n_threads; i++) {
        std::cout << std::get<0>(times_taken[i]) << ", " << std::get<1>(times_taken[i]) << std::endl;
    }

    std::cout << "Time taken (in seconds) : " << total_time_taken << "\n";
}

// https://www.educative.io/answers/how-to-check-if-a-number-is-a-power-of-2-in-cpp
void validateNumSamplesToBePowerOfTwo(uint n_samples) {
    uint i = n_samples & (n_samples - 1);

    if (i != 0) {
        throw std::invalid_argument("The number of samples provided must be power of two.");
    }
}

void printFirstOutputs(std::vector<std::complex<double>>& output_signal, uint n_samples) {

    if (n_samples <= 8) {
        // If there are only a few samples print all of the results
        std::cout << std::endl;
        std::cout << "First " << n_samples << " samples:" << std::endl;
        int item_counter = 1;
        for (const auto& item : output_signal) {
            std::cout << item_counter << ". " << item << std::endl;
            item_counter++;
        }
    } else {
        // If there are more samples only print the first 10
        std::cout << std::endl;
        std::cout << "First 10 samples:" << std::endl;
        for (int i = 1; i < 11; i++) {
            std::cout << i << ". " << output_signal[i] << std::endl;
        }
    }     
}

int main(int argc, char *argv[]) { 
    cxxopts::Options options(
        "Fast_Fourier_Transfrom",
        "Calculate the Fourier Transform of a sine wave using parallel execution.");
    options.add_options(
        "",
        {
            {"n_samples", "Number of Samples", 
            cxxopts::value<uint>()->default_value(DEFAULT_NUMBER_OF_SAMPLES)},
            {"amplitude", "Amplitude of the Sine Wave",
            cxxopts::value<double>()->default_value(DEFAULT_AMPLITUDE)},
            {"frequency", "Frequency of the Sine Wave",
            cxxopts::value<double>()->default_value(DEFAULT_FREQUENCY)},
            {"sampling_rate", "Sampling Rate",
            cxxopts::value<double>()->default_value(DEFAULT_SAMPLING_RATE)},
            {"n_threads", "Number of Threads",
            cxxopts::value<uint>()->default_value(DEFAULT_NUM_OF_THREADS)}
        });

        auto cl_options = options.parse(argc, argv);
        uint n_samples = cl_options["n_samples"].as<uint>();
        double amplitude = cl_options["amplitude"].as<double>();
        double frequency = cl_options["frequency"].as<double>();
        double sampling_rate = cl_options["sampling_rate"].as<double>();
        uint n_threads = cl_options["n_threads"].as<uint>();

        // Validate the number of samples to be power of two to satisfy the Cooley-Tukey algorithm assumption
        try {
            validateNumSamplesToBePowerOfTwo(n_samples);
        } catch (const std::invalid_argument& error) {
            std::cerr << "Caught an invalid argument exception: " << error.what() << std::endl;
            std::exit(EXIT_FAILURE);
        }

        // Print the command line inputs
        std::cout << "Number of Samples: " << n_samples << std::endl;
        std::cout << "Amplitude: " << amplitude << std::endl;
        std::cout << "Frequency: " << frequency << " Hz" << std::endl;
        std::cout << "Sampling Rate: " << sampling_rate << " Hz" << std::endl;
        std::cout << "Number of Threads: " << n_threads << std::endl;

        // Generate a sine wave to be used for Fast Fourier Transform
        auto sine_wave = generateSineWave(n_samples, amplitude, frequency, sampling_rate);

        // Execute the parallel version of FFT
        std::vector<std::complex<double>> output_data(n_samples);
        parallelFFT(sine_wave, output_data, n_samples, n_threads);

        // Print the fist few outputs
        printFirstOutputs(output_data, n_samples);
}
