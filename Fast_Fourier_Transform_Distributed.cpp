#include "core/cxxopts.h"
#include "core/get_time.h"
#include "core/utils.h"

#include <iostream>
#include <vector>
#include <complex>
#include <cmath>

#include <mpi.h>

#define DEFAULT_NUMBER_OF_SAMPLES "1024"
#define DEFAULT_AMPLITUDE "1.0"
#define DEFAULT_FREQUENCY "50.0"
#define DEFAULT_SAMPLING_RATE "1000.0"

#define PI M_PI
#define BASE 2.0
#define EXPONENTIAL_PART (std::pow(BASE, 2 * PI))
#define IMAGINARY_UNIT std::complex<double>(0, 1)
#define OMEGA(n_samples) ((EXPONENTIAL_PART * IMAGINARY_UNIT) / static_cast<double>(n_samples))

/** 
 * (This comment has been generated by GenAI based on the implementation of the function).
 * @brief Generates a sine wave sampled at regular intervals.
 * 
 * This function creates a sine wave based on the specified number of samples, amplitude,
 * frequency, and sampling rate. The resulting sine wave is represented as a vector of
 * complex numbers, where the real part contains the sine wave values, and the imaginary 
 * part is set to 0.0 (useful for FFT processing).
 * 
 * @param n_samples The total number of samples to generate.
 * @param amplitude The amplitude of the sine wave (peak value).
 * @param frequency The frequency of the sine wave in Hz (cycles per second).
 * @param sampling_rate The rate at which the sine wave is sampled in Hz (samples per second).
 * @return std::vector<std::complex<double>> A vector containing the sampled sine wave values 
 *         as complex numbers with 0.0 as the imaginary part.
 */
std::vector<std::complex<double>> generateSineWave(uint n_samples, double amplitude, double frequency, double sampling_rate) {
    // Vector to store the samples from the sine wave
    std::vector<std::complex<double>> sine_wave(n_samples);

    for (uint n = 0; n < n_samples; ++n) {
        double time_step = n / sampling_rate;
        // Compute the value of the sine wave at the current time step
        double value = amplitude * std::sin(2 * M_PI * frequency * time_step);
        sine_wave[n] = {value, 0.0};
    }

    return sine_wave;
}

// https://www.educative.io/answers/how-to-check-if-a-number-is-a-power-of-2-in-cpp
void validateNumSamplesToBePowerOfTwo(uint n_samples) {
    uint i = n_samples & (n_samples - 1);

    if (i != 0) {
        throw std::invalid_argument("The number of samples provided must be power of two.");
    }
}


void iterativeFFT_MPI(std::vector<std::complex<double>>& input_signal, 
                  std::vector<std::complex<double>>& output_signal, 
                  int n_samples, int start, int end,
                  std::vector<std::complex<double>>& local_signal,
                  int local_n, int rank) {
    output_signal = input_signal;
    size_t N = static_cast<size_t>(n_samples);
    size_t j = 0;
    for (size_t i = 1; i < N; ++i) {
        size_t bit = N >> 1;
        while (j & bit) {
            j ^= bit;
            bit >>= 1;
        }
        j ^= bit;
        if (i < j) {
            std::swap(output_signal[i], output_signal[j]);
        }
    }

    int log_n = std::log2(n_samples);
    for (int stage = 1; stage <= log_n; ++stage) {
        int len = 1 << stage;
        double angle = -2.0 * PI / len;
        std::complex<double> wlen(std::cos(angle), std::sin(angle));

        for (int i = start; i < N; i += len) {
            std::complex<double> w(1.0);
            for (int j = 0; j < len / 2; ++j) {
                int index1 = i + j;
                int index2 = index1 + len / 2;
                std::complex<double> u = output_signal[index1];
                std::complex<double> v = output_signal[index2] * w;
                output_signal[index1] = u + v;
                output_signal[index2] = u - v;
                w *= wlen;
            }
        }
    }
}


void printFirstOutputs(std::vector<std::complex<double>>& output_signal, uint n_samples) {

    if (n_samples <= 8) {
        // If there are only a few samples print all of the results
        std::cout << std::endl;
        std::cout << "First " << n_samples << " samples:" << std::endl;
        int item_counter = 1;
        for (const auto& item : output_signal) {
            std::cout << item_counter << ". " << item << std::endl;
            item_counter++;
        }
    } else {
        // If there are more samples only print the first 10
        std::cout << std::endl;
        std::cout << "First 10 samples:" << std::endl;
        for (int i = 1; i < 11; i++) {
            std::cout << i << ". " << output_signal[i] << std::endl;
        }
    }     
}

int main(int argc, char *argv[]) {
    MPI_Init(&argc, &argv);

    int rank, size;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    cxxopts::Options options(
        "Fast_Fourier_Transfrom",
        "Calculate the Fourier Transform of a sine wave using serial execution.");
    options.add_options(
        "",
        {
            {"nSamples", "Number of Samples", 
            cxxopts::value<uint>()->default_value(DEFAULT_NUMBER_OF_SAMPLES)},
            {"amplitude", "Amplitude of the Sine Wave",
            cxxopts::value<double>()->default_value(DEFAULT_AMPLITUDE)},
            {"frequency", "Frequency of the Sine Wave",
            cxxopts::value<double>()->default_value(DEFAULT_FREQUENCY)},
            {"samplingRate", "Sampling Rate",
            cxxopts::value<double>()->default_value(DEFAULT_SAMPLING_RATE)}
        });

    auto cl_options = options.parse(argc, argv);
    uint n_samples = cl_options["nSamples"].as<uint>();
    double amplitude = cl_options["amplitude"].as<double>();
    double frequency = cl_options["frequency"].as<double>();
    double sampling_rate = cl_options["samplingRate"].as<double>();

    try {
        validateNumSamplesToBePowerOfTwo(n_samples);
    } catch (const std::invalid_argument& error) {
        if (rank == 0) std::cerr << error.what() << std::endl;
        MPI_Finalize();
        return EXIT_FAILURE;
    }

    // Print the command line inputs
    if (rank == 0) {
        std::cout << "Number of Samples: " << n_samples << std::endl;
        std::cout << "Amplitude: " << amplitude << std::endl;
        std::cout << "Frequency: " << frequency << " Hz" << std::endl;
        std::cout << "Sampling Rate: " << sampling_rate << " Hz" << std::endl;
    }

        // Generate sine wave
    auto sine_wave = generateSineWave(n_samples, amplitude, frequency, sampling_rate);

    if (rank == 0) {
        std::cout << "Running MPI FFT with " << size << " processes.\n";
        // printFirstOutputs(sine_wave, n_samples);
    }

    // Define work ranges
    uint local_n = n_samples / size;
    int start = rank * local_n;
    int end = (rank + 1) * local_n;

    // Allocate output buffer
    std::vector<std::complex<double>> local_output_signal(n_samples);
    std::vector<std::complex<double>> local_signal(n_samples);

    MPI_Barrier(MPI_COMM_WORLD);
    double start_time = MPI_Wtime();

    // Perform FFT in the specified range
    iterativeFFT_MPI(sine_wave, local_output_signal, n_samples, start, end, local_signal, local_n, rank);

    MPI_Barrier(MPI_COMM_WORLD);
    double end_time = MPI_Wtime();

    // Gather full result on root process
    std::vector<std::complex<double>> gathered_output(n_samples);
    MPI_Gather(local_output_signal.data(), local_n, MPI_DOUBLE_COMPLEX,
               gathered_output.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);

    if (rank == 0) {
        std::cout << "Parallel FFT completed in " << (end_time - start_time) << " seconds.\n";
        printFirstOutputs(gathered_output, n_samples);
    }

    MPI_Finalize();
    return 0;
}
